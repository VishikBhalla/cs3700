## High Level Approach
Since UDP has no concept of sequence numbers or acknowledgements, our first priority was to add those. We began by reading the data from stdin into a buffer, constructing "packets" and assigning sequence numbers to each one corresponding to the accumulated length of the data up to this packet. The other fields included in the packet are the ack, data, timestamp, and eof fields. The end of file message is constructed with an empty string data message and eof set to True. 
Our approach was to send a message to the receiver, and upon receiving it, the receiver keeps track of it in its own buffer, and sends an acknowledgement for the last message for which we have received all packets up to and including it. This ensures that if a packet is dropped, the receiver has a reliable way to notify the sender which packet it needs to start retransmitting at. The receiver is also limited in the number of acks sent within a timeout window so the network is not flooded with identical acks.
We implemented a sliding window so that the sender and receiver are able to transmit data more efficiently. This was achieved by adjusting the number of packets that could be sent and unacknowledged, so that when there was a high proportion of messages unacknowledged, the window would shrink, minimizing the number of repeated packets sent until it was confirmed that the packets we had sent were acknowledged, at which point the window size would increase.
Our next priority was implementing a timeout. This is needed not only to help optimize the efficiency of the protocol, but also to confirm that if the sender has not received all the acknowledgements for all sent messages and has timed out, then the sender needs to resend. The timestamps on a sent packet and its corresponding acknowledgement were used to calculate the round-trip time, and that was used to modify the timeout. 
The final phase of our protocol is the teardown. Once the receiver receives the EOF message AND has received and acknowledged all proceeding messages, it is able to send the ACK for the EOF. At this point it enters a loop on a timeout where if it receives any more messages from the sender, it acknowledges them and sets the count to 0. Otherwise, it begins sending the EOF ACK and incrementing the count up to 10. This is done so that in case of packet drops, the sender has multiple opportunities to receive the EOF ACK. Finally, once count is 10, the program exits gracefully. The sender has a less complicated teardown procedure, simply exiting gracefully once it has received the EOF ACK.

## Challenges Faced
As we tested under different conditions, we would discover edge cases and have to modify parts of our protocol. For instance, when we increased the delay and latency, we discovered issues with the timeout logic. When we changed the drop rate and duplication rate, we discovered issues with our window logic. We were able to debug these and continue on. A large part of our challenges dealt with decreased performance when these conditions were compiled; getting our program to be efficient and correct while dealing with drops, delays, duplications etc. all at once was the most difficult part of this project, while figuring out what the protocol would need to consist of was relatively straightforward. 

## Testing
We utilized logging throughout the project, paying attention of which messages were received and which ones were acknowledged, the time between those two events, the progression of the sequence and acknowledgement numbers, etc. We also utilized the test script, running our programs under different circumstances, modifying the bandwidth, latency, delay, drop rate, reorder rate, and duplication rate -- individually as well as combined, and analyzed the output under each of these circumstances. Our final way of testing the program was to connect the sender and receiver and send messages between two terminal windows. This allowed us to see in real time how our program was working to send one message at a time.
