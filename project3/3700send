#!/usr/bin/python -u
#
# Project 2 Starter Code
#

import sys
import socket
import time
import datetime
import select
import json

MSG_SIZE = 1500
DATA_SIZE = 1000
TIMEOUT = 1
SEQUENCE = 0
buff = []
window = 20
window_timeout = 0.5

# Bind to localhost and an ephemeral port
IP_PORT = sys.argv[1]
UDP_IP = IP_PORT[0:IP_PORT.find(":")]
UDP_PORT = int(IP_PORT[IP_PORT.find(":")+1:])
dest = (UDP_IP, UDP_PORT)

# Set up the socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) 
sock.settimeout(TIMEOUT)

def log(string):
  sys.stderr.write(datetime.datetime.now().strftime("%H:%M:%S.%f") + " " + string + "\n")

def read_all_data():
  global SEQUENCE
  global buff
  
  while True:
    data = sys.stdin.read(DATA_SIZE)
    if(len(data) > 0):
      msg = {"sequence": SEQUENCE, "data": data, "ack": False, "eof": False}
      SEQUENCE += len(data)
      buff.append(msg)
    else:
      msg = {"sequence": SEQUENCE, "data": '', "ack": False, "eof": True}
      buff.append(msg)
      break

def send_individual_packet(index):
  buff[index]['timestamp'] = time.time()
  msg = json.dumps(buff[index])

  if sock.sendto(msg, dest) < len(msg):
    log("[error] unable to fully send packet")
  else:
    log("[send data] " + str(buff[index]["sequence"]) + " (" + str(len(buff[index]["data"])) + ")")

def send_window_packets(sequence_number):
  n = buff.index([m for m in buff if m["sequence"] == sequence_number][0])
  for i in range(n, min(n+window, len(buff))):
    send_individual_packet(i)


def clear_socket():
    global sock
    input = [sock]
    while 1:
        inputready, o, e = select.select(input,[],[], 0.0)
        if len(inputready)==0: break
        for s in inputready: s.recv(1)

def receive_window_acks(last_acked_seq_num):
  highest_ack = last_acked_seq_num

  for i in range(0,window):
    result = sock.recvfrom(MSG_SIZE)
    if result:
      (data, addr) = result
      try:
        decoded = json.loads(data)
        log("[recv ack] " + str(decoded["ack"]))
        if decoded['ack'] > highest_ack:
          highest_ack = decoded["ack"]
      except (ValueError, KeyError, TypeError) as e:
        log("[recv corrupt packet]")
        raise e
    else:
      pass    
  clear_socket()  
  return highest_ack

read_all_data()

sock.settimeout(window_timeout)

# highest_acked_seq_num = 0
# while highest_acked_seq_num + 1 < buff[-1]["sequence"]:
#   send_window_packets(highest_acked_seq_num)
#   highest_acked_seq_num = receive_window_acks(highest_acked_seq_num)

# connection teardown
# sys.exit(0)

# Now read in data, send packets
# resend data if we get two acks in a row for the same sequence number
index = 0
lastack = 0
send_individual_packet(0)
timeSent = time.time()
estimated_rtt = window_timeout
dev_rtt = window_timeout
receivedMessage = None
while True:
  # log("ABOUT TO SLEEP")

  if not receivedMessage or receivedMessage['timestamp'] - timeReceived < window_timeout:
    send_individual_packet(index)
    timeSent = time.time()

  result = sock.recvfrom(MSG_SIZE) #receiving ACK
  timeReceived = time.time()

  sample_rtt = timeReceived - timeSent
  estimated_rtt = estimated_rtt * 0.875 + sample_rtt * 0.125
  dev_rtt = 0.75 * dev_rtt + 0.25 * abs(sample_rtt - estimated_rtt)
  sock.settimeout(estimated_rtt + 4 * dev_rtt)

  if result:
    (data, addr) = result
    try:
      decoded = json.loads(data)
      receivedMessage = decoded

      if decoded['ack'] - 1 == buff[-1]['sequence']:
        # were done woohoo
        break
      elif decoded['ack'] == buff[index]['sequence'] + len(buff[index][data]):
        index += 1
        continue
      # elif decoded['ack'] == lastack:
      #   log("[recv ack] " + str(lastack))
      #   # resend the data that comes after lastack
      #   msgtoresend = buff[buff.index([b for b in buff if b['sequence'] + len(b['data']) == lastack][0]) + 1]
      #   if sock.sendto(msgtoresend, dest) < len(msgtoresend):
      #     log("[error] unable to fully send packet")
      #   else:
      #     log("[send data] " + str(lastack) + " (" + str(len(data)) + ")")


      # lastack = decoded['ack']

    except (ValueError, KeyError, TypeError) as e:
      log("[recv corrupt packet]")
      raise e
  else:
    log("[error] timeout")
    send_all_data()

sock.sendto(json.dumps({"eof": True, "data": "", "sequence": SEQUENCE, "ack": False}), dest)
sys.exit(0)
