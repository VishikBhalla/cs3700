#!/usr/bin/python -u
#
# Project 2 Starter Code
#

import sys
import socket
import time
import datetime
import select
import json

MSG_SIZE = 1500
DATA_SIZE = 1000
TIMEOUT = 1
SEQUENCE = 0
buff = []
window = 20
window_timeout = 0.2

# Bind to localhost and an ephemeral port
IP_PORT = sys.argv[1]
UDP_IP = IP_PORT[0:IP_PORT.find(":")]
UDP_PORT = int(IP_PORT[IP_PORT.find(":")+1:])
dest = (UDP_IP, UDP_PORT)

# Set up the socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) 
sock.settimeout(TIMEOUT)

def log(string):
  sys.stderr.write(datetime.datetime.now().strftime("%H:%M:%S.%f") + " " + string + "\n")

def read_all_data():
  global SEQUENCE
  global buff
  
  while True:
    data = sys.stdin.read(DATA_SIZE)
    if(len(data) > 0):
      msg = {"sequence": SEQUENCE, "data": data, "ack": False, "eof": False}
      SEQUENCE += len(data)
      buff.append(msg)
    else:
      msg = {"sequence": SEQUENCE, "data": '', "ack": False, "eof": True}
      buff.append(msg)
      break

def send_individual_packet(index):
  buff[index]['timestamp'] = time.time()
  msg = json.dumps(buff[index])

  if sock.sendto(msg, dest) < len(msg):
    log("[error] unable to fully send packet")
    return False
  else:
    log("[send data] " + str(buff[index]["sequence"]) + " (" + str(len(buff[index]["data"])) + ")")
    return True

def send_window_packets(sequence_number):
  n = buff.index([m for m in buff if m["sequence"] == sequence_number][0])
  for i in range(n, min(n+window, len(buff))):
    send_individual_packet(i)

read_all_data()
for b in buff:
  log(json.dumps(b))


# send a packet THEN begin receiving
# continue until receive correct packet 
# OR timeout

index = 0
msg_timeout = 0.1
rtt_moving_avg = 0.1

last_seq_num_sent = 0
last_seq_num_acked = 0
last_index_acked = 0
sliding_window_initial_size = 50
current_window_size = sliding_window_initial_size

eof_sent_once = False

while True:
  # process acks
  ready = []
  if current_window_size == 0:
    ready = select.select([sock],[],[],msg_timeout) # select with timeeout
  
  while True:
    ready = select.select([sock],[],[],0) # poll for readable
    if ready[0]:
      # process ack
      (data, addr) = sock.recvfrom(MSG_SIZE)
      try:
        decoded = json.loads(data)

        # update RTT estimates
        timeReceived = time.time()
        timeSent = decoded['timestamp']
        sample_rtt = timeReceived - timeSent
        rtt_moving_avg = rtt_moving_avg * 0.875 + sample_rtt * 0.125
        msg_timeout = 1.5 * rtt_moving_avg
        
        # if we got final ack, quit
        if decoded['ack'] - 1 == buff[-1]['sequence']:
          sys.exit(0)

        # if ack is the same as last highest ack, do nothing
        # if ack is different from last highest ack, we have a new highest ack
        # and we update window size by number of unacked packets between the two "highest acks"
        # also, if our new highest ack is greater than last seq num sent, update last sent
        if decoded['ack'] != last_seq_num_acked:
          message_just_acked = [m for m in buff if m['sequence'] == decoded['ack']][0]
          message_index = buff.index(message_just_acked)
          current_window_size += message_index - last_index_acked
          last_index_acked = message_index
          last_seq_num_acked = decoded['ack']
          if last_seq_num_acked > last_seq_num_sent:
            last_seq_num_sent = last_seq_num_acked

      except (ValueError, KeyError, TypeError) as e:
        # received a corrupt packet, keep looping through recv
        log("[recv corrupt packet]")
        continue

    else:
      break

  eof = False
  # eof case
  if last_seq_num_sent == buff[-1]['sequence']:
    eof = True

  # send data
  just_timed_out = False
  if current_window_size == 0:
    just_timed_out = True
    current_window_size == sliding_window_initial_size
    last_seq_num_sent = last_seq_num_acked

  message_to_send = None
  if eof:
    message_to_send = buff[-1]
  else:
    message_to_send = [m for m in buff if m["sequence"] == last_seq_num_sent][0]
  
  index_to_send = buff.index(message_to_send)
  
  # we only want to send eof message if 1) it has not been sent OR 2) we have just reset
  if eof:
    if not eof_sent_once or just_timed_out:
      log("Sending EOF again!!! " + str(eof_sent_once) +" | "+ str(just_timed_out))
      if send_individual_packet(index_to_send):
        eof_sent_once = True
        current_window_size -= 1
        last_seq_num_sent = message_to_send['sequence'] + 1
  elif send_individual_packet(index_to_send):
    current_window_size -= 1
    last_seq_num_sent += len(message_to_send['data'])


while True:
  log("Beginning send loop for index" + str(index))
  send_individual_packet(index)

  # receive loop
  while True:
    log("Beginning receive loop for index" + str(index))
     
    ready = select.select([sock],[],[],msg_timeout)    
    
    if ready[0]:
      (data, addr) = sock.recvfrom(MSG_SIZE)
      try:
        # decode the data
        decoded = json.loads(data)
        log("Received message from receiver: " + data)
      
        # update RTT estimates
        timeReceived = time.time()
        timeSent = decoded['timestamp']
        sample_rtt = timeReceived - timeSent
        log("sample RTT: " + str(sample_rtt))
        rtt_moving_avg = rtt_moving_avg * 0.875 + sample_rtt * 0.125
        msg_timeout = 1.5 * rtt_moving_avg




        # first, check if we have received the eof, in which case we are done
        if decoded['ack'] - 1 == buff[-1]['sequence']:
          sys.exit(0)

        # next, check if we have received the ack for the current packet, in which case move on o the next send
        # note, we do not need to check if we're expecting an eof
        if index != len(buff) -1 and decoded['ack'] == buff[index + 1]['sequence']:
          log('received correct ack for newly sent packet')
          # if our packet has been acked, increment the index and keep on keepin' on
          index += 1
          break

      except (ValueError, KeyError, TypeError) as e:
        # received a corrupt packet, keep looping through recv
        log("[recv corrupt packet]")
        continue
    else:
      # if we timeout, resend the packet
      log("[error] timeout, resending packet #" + str(index))
      break

# highest_acked_seq_num = 0
# while highest_acked_seq_num + 1 < buff[-1]["sequence"]:
#   send_window_packets(highest_acked_seq_num)
#   highest_acked_seq_num = receive_window_acks(highest_acked_seq_num)

# connection teardown
# sys.exit(0)

# Now read in data, send packets
# resend data if we get two acks in a row for the same sequence number
index = 0
lastack = 0
send_individual_packet(0)
estimated_rtt = window_timeout
dev_rtt = window_timeout
receivedMessage = None
t = 1
while True:
  # log("ABOUT TO SLEEP")

  if not receivedMessage or receivedMessage['timestamp'] - timeReceived < t:
    send_individual_packet(index)

  result = sock.recvfrom(MSG_SIZE) #receiving ACK

  if result:
    (data, addr) = result
    try:
      decoded = json.loads(data)
      receivedMessage = decoded
      timeReceived = time.time()

      timeSent = receivedMessage['timestamp']
      sample_rtt = timeReceived - timeSent
      log("sample RTT: " + str(sample_rtt))
      estimated_rtt = estimated_rtt * 0.875 + sample_rtt * 0.125
      dev_rtt = 0.75 * dev_rtt + 0.25 * abs(sample_rtt - estimated_rtt)
      t = estimated_rtt + 4 * dev_rtt
      sock.settimeout(t)

      # log(str(index))
      # log('decoded[ack] = ' + str(decoded['ack']))
      # log('buff[-1][sequence] = ' + str(buff[-1]['sequence']))

      if decoded['ack'] - 1 == buff[-1]['sequence']:
        log(str(buff[-1]['sequence']) + " all done")
        # were done woohoo
        break
      elif index != len(buff) - 1 and decoded['ack'] == buff[index]['sequence'] + len(buff[index]['data']):
        index += 1
        continue
      # elif decoded['ack'] == lastack:
      #   log("[recv ack] " + str(lastack))
      #   # resend the data that comes after lastack
      #   msgtoresend = buff[buff.index([b for b in buff if b['sequence'] + len(b['data']) == lastack][0]) + 1]
      #   if sock.sendto(msgtoresend, dest) < len(msgtoresend):
      #     log("[error] unable to fully send packet")
      #   else:
      #     log("[send data] " + str(lastack) + " (" + str(len(data)) + ")")


      # lastack = decoded['ack']

    except (ValueError, KeyError, TypeError) as e:
      log("[recv corrupt packet]")
      raise e
  else:
    log("[error] timeout")
    send_all_data()

sock.sendto(json.dumps({"eof": True, "data": "", "sequence": SEQUENCE, "ack": False}), dest)
sys.exit(0)
