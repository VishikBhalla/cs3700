#!/usr/bin/python -u

import argparse
import sys
import socket
import json
import time
#import parseurl
#import html
#import html.parser
#import xml

from HTMLParser import HTMLParser

csrfToken = 'start token'
sessionId = 'start session id'
frontier = []
visited = set()
hostname = 'fring.ccs.neu.edu'
port = 80
flag_count = 0

DEBUG = False

class CrawlParser(HTMLParser):
  foundflag = False

  def handle_starttag(self, tag, attrs):
    global frontier
    global visited
    attrDict = {}
    if tag != 'h2' and tag != 'a':
      return

    for attr in attrs:
      attrDict[attr[0]] = attr[1]
    
    if tag == 'h2' and attrDict.get('class') == 'secret_flag':
      self.foundflag = True 
    elif tag == 'a':
      href = attrDict.get('href')
      if href.startswith('/fakebook') and href not in visited:
        frontier.append(attrDict.get('href'))
  
  def handle_endtag(self, tag): 
    return

  def handle_data(self, data):
    global flag_count
    if self.foundflag:
      print(data)
      self.foundflag = False
      flag_count = flag_count + 1
      if flag_count == 5:
        exit(0)


def login(sock, username, password):
  global csrfToken
  global sessionId
  if DEBUG:
    print('Username:', username)
    print('Password:', password)
  request_path = '/accounts/login/?next=/fakebook/'
  r =  ('GET {0} HTTP/1.1\n'
        'Host: fring.ccs.neu.edu\n'
        'Connection: keep-alive\n\n').format(request_path)
  sock.sendall(r)
  mes = receiveMessage(sock)
  
  if mes['statusCode'] == '200':
    if DEBUG:
      print('good 200')
  else:
    print('error')
    print(json.dumps(mes))
    return

  csrfToken = mes['cookies']['csrftoken']['value']
  sessionId = mes['cookies']['sessionid']['value']
 
  if DEBUG:
    print("Token:")
    print(csrfToken)

  requestUrl = 'http://fring.ccs.neu.edu/accounts/login/'
  requestBody = 'username=' + username + '&password=' + password + '&csrfmiddlewaretoken=' + csrfToken + '&next=%2Ffakebook%2F'
  r = 'POST /accounts/login/ HTTP/1.1 \n' + 'Host: fring.ccs.neu.edu\n'
  r = r + 'Cookie: csrftoken=' + csrfToken + '; sessionid=' + sessionId + ';\n'
  r = r + 'Referer: http://fring.ccs.neu.edu/accounts/login/?next=/fakebook/\n'
  r = r + 'Content-Type: application/x-www-form-urlencoded\n'
  r = r + 'Connection: keep-alive\n'
  r = r + 'Content-Length: ' + str(len(requestBody)) + '\n\n'
  r = r + requestBody + '\n\n'
  sock.sendall(r)
  
  if DEBUG:
    print(r)
  
  mes = receiveMessage(sock)
  
  if DEBUG:
    print(json.dumps(mes))
  
  if mes.get('statusCode') != '200' and mes.get('statusCode') != "302":
    print('error loggin ing!')
    print(json.dumps(mes, indent=2))
    exit(1)

  sessionId = mes['cookies']['sessionid']['value']
  frontier.append('/fakebook/');
  return  
"""
read from socket until we see /r/n/r/n
at this point parse the headers
if ContentLength, read from buffer normally
if Transfer-Encoding == chunked, 
"""
def extract_headers(mes_header, d):
  # parse headers
  firstPart = mes_header.split('\r\n')
  d["statusCode"] = firstPart[0].split(' ')[1]
  d['headers'] = {}
  d['cookies'] = {}
  for line in firstPart[1:]:
    parts = line.split(': ')
    if parts[0] == 'Set-Cookie':
      cookie_parts = parts[1].split('; ')
      first_cookie_part = cookie_parts[0].split('=')
      d['cookies'][first_cookie_part[0]] = {}
      d['cookies'][first_cookie_part[0]]['value'] = first_cookie_part[1]
      for cookie_part in cookie_parts[1:]:
        split_part = cookie_part.split('=')
        d['cookies'][first_cookie_part[0]][split_part[0]] = split_part[1]
    else:
      d['headers'][parts[0]] = parts[1]
  return 
 
def read_content_length(sock, d, body_so_far):
  mes_string = body_so_far
  content_length = int(d['headers']['Content-Length'])
  bytes_left = content_length - len(mes_string)
  while bytes_left > 0:
    bytes_to_read = min(bytes_left, 4096)
    databuff = sock.recv(bytes_to_read)
    mes_string = mes_string + databuff
    bytes_left = bytes_left - len(databuff)
  
  d['data'] = mes_string
  return d
  
def get_chunklen(buff):
  buff = buff.lstrip()
  split_buff = buff.split("\r\n")
  return (int(split_buff[0], 16), "\r\n".join(split_buff[1:]))

def read_chunked_encoding(sock, d, body_so_far):
  if body_so_far == "":
    body_so_far = sock.recv(4096)
  body_string = ""
  chunklen, body_so_far = get_chunklen(body_so_far) 
  chunk_string = ""
  while True:
    if chunklen <= len(body_so_far):
      chunk_string = chunk_string + body_so_far[0:chunklen]
      body_so_far = body_so_far[chunklen:]
      body_string = body_string + chunk_string
      chunk_string = ""
      # check if we habe more chunks or we're done
      if body_so_far.lstrip() == "":
        body_so_far = sock.recv(4096)
      chunklen, body_so_far = get_chunklen(body_so_far) 
      if chunklen == 0:
        break
    else:
      chunk_string = chunk_string + body_so_far
      chunklen = chunklen - len(body_so_far)
      body_so_far = sock.recv(4096)
  d['data'] = body_string
  return d

def read_until_empty(sock, d, body_so_far):
  body_str = body_so_far          
  read = sock.recv(4096)
  while read:
    body_str = body_str + read
    read = sock.recv(4096)

  d['data'] = body_str
  return d

def receiveMessage(sock):
  fullbuff = ''
  d = {}
  mes_header = ''
  mes_body = ''
  body_bytes_received = 0
  content_length = 0
  chunked = False
  while 1:
    databuff = sock.recv(4096)
    fullbuff = fullbuff + databuff
    
    if DEBUG:
      print(fullbuff)
    
    end_header_index = databuff.find('\r\n\r\n')
    if end_header_index == -1:
      mes_header += databuff
    else:
      databuff_parts = databuff.split('\r\n\r\n')
      mes_header += databuff_parts[0]

      # parse header information into data structure
      extract_headers(mes_header, d)
      body_so_far = "" if len(databuff_parts) == 1 else databuff_parts[1]       

      if d['headers'].get('Content-Length'):
        return read_content_length(sock, d, body_so_far)
      elif d['headers'].get('Transfer-Encoding') and d['headers']['Transfer-Encoding'] == 'chunked':
        try:
          return read_chunked_encoding(sock, d, body_so_far)
        except ValueError as e:
          print(e)
          print(json.dumps(d))
          print(body_so_far)
      else:
        return read_until_empty(sock, d, body_so_far)
 

    # if last received character was a newline, we're done receiving the message
    if body_bytes_received == content_length:
      d['data'] = mes_body
      #print('# received message')
      break
  return d

def build_request(path, csrfToken, sessionId):
  r =  ("GET {0} HTTP/1.1\n"
        "Host: fring.ccs.neu.edu\n"
        "Cookie: csrftoken={1}; sessionid={2};\n"
        "Connection: keep-alive\n\n").format(path, csrfToken, sessionId)
  return r 

def crawl(sock):
  global frontier
  global visited
  global sessionId
  global csrfToken
  global hostname
  global port
  if DEBUG:
    print('SESSION ID: ' + sessionId) 
  
  parser = CrawlParser()

  while frontier:
#    if DEBUG:
#      print('Frontier')
 #     print(json.dumps(frontier))
  #    print('Visited')
   #   print(visited)

    next_link = frontier.pop()
    request = build_request(next_link, csrfToken, sessionId)
    
    if DEBUG:
      print('REQUEST')
      print(request)

    sock.sendall(request)
    response = receiveMessage(sock)
    if not response.get('statusCode'):
      print("About to cause an error")
      print(json.dumps(response, indent=2))
    if response['statusCode'] == '200':
      visited.add(next_link)
      parser.feed(response['data'])
      if response['cookies'].get('sessionid'):
        sessionId = response['cookies']['sessionid']['value']
    elif response['statusCode'] == '500':
      frontier.append(next_link)
      time.sleep(1)
    elif response['statusCode'] == '403' or response['statusCode'] == '404':
      visited.add(next_link)
    else:
      print("Got a unhandled response")
      print(json.dumps(response))
      exit(1)
 
    if response['headers']['Connection'] == 'close':
      sock.shutdown(socket.SHUT_RDWR)
      sock.close()
      sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
      sock.settimeout(5)
      sock.connect((hostname,port))

def main():
  # Parse command line arguments
  parser = argparse.ArgumentParser(description='Simple webcrawler')
  parser.add_argument('user')
  parser.add_argument('password')
  args = parser.parse_args(sys.argv[1:]) # arguments exclude filename

  username = args.user
  password = args.password
  
  # Create a TCP/IP socket
  sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

  hostname = 'fring.ccs.neu.edu'
  port = 80

  # get remote ip
  #remote_ip = socket.gethostbyname(hostname)
  #print('# Connecting to server, ' + hostname + ' (' + remote_ip + ')')
  
  # set the socket timeout and connect
  sock.settimeout(5)
  sock.connect((hostname, port))

  # print("# Connected")
  login(sock, username, password)

  # crawl
  crawl(sock)

if __name__ == "__main__":
  main()
