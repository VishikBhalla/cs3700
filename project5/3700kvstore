#!/usr/bin/env python

import sys, socket, select, time, json, random

######################################
######## pre-loop definitions ########
######################################

# cluster size
cluster_size = len(sys.argv) - 1

# Your ID number
my_id = sys.argv[1]

# The ID numbers of all the other replicas
replica_ids = sys.argv[2:]

# get pretty colors for printing
colors = []
for i in range(256):
  colors.append(u"\u001b[38;5;" + str(i) + "m")
sorted_ids = sorted(sys.argv[1:])
my_color = colors[(1 + sorted_ids.index(my_id)) % 256]


# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
sock.connect(my_id)

last_leader_msg = time.time()
is_leader = False

def et():
  return random.uniform(0.1, 0.3)

election_timeout = et()

leader = 'FFFF'

currentTerm = 0
votedFor = {}
votesReceived = []
is_holding_election = False

log = []

commitIndex = -1
lastApplied = -1

# leader state
nextIndex = {} 
matchIndex = {} #lastapplieds

heartbeat_timeout = 0.1
last_heartbeat = time.time()

kvstore = {}

DEBUG = False

received_buffer = []

######################################
######## function definitions ########
######################################

def debug(msg, **kwargs):
  if DEBUG or kwargs.get('force'):
    print(my_color + "Replica " + str(my_id) + " :: " + str(time.time()) + " :: " + msg + '\033[0m')

def build_appent(entries, dst, prevLogIndex, prevLogTerm):
  global my_id, sock, received_buffer, leader, currentTerm, replica_ids, sock, last_heartbeat, votedFor
  htbt = {}
  htbt['src'] = my_id
  htbt['dst'] = dst
  htbt['leader'] = leader
  htbt['type'] = 'appent'
  htbt['entries'] = entries
  htbt['term'] = currentTerm
  htbt['prevLogIndex'] = prevLogIndex
  htbt['prevLogTerm'] = prevLogTerm
  htbt['leaderCommit'] = commitIndex
  return htbt
  
def get_entries(rid):
  global log, nextIndex
  return log[nextIndex[rid]:][0:100] 

def send_to_replicas(key, val):
  debug("Sending appent to replicas")
  global my_id, sock, received_buffer, leader, commitIndex, currentTerm, nextIndex, log, replica_ids, sock, last_heartbeat, votedFor
  
  appents = dict()
  for rid in replica_ids:
    entries = get_entries(rid)
    prevLogIndex = nextIndex[rid] - 1
    prevLogTerm = 0 if prevLogIndex is -1 else log[prevLogIndex]['term']
    appents[rid] = json.dumps(build_appent(entries, rid, prevLogIndex, prevLogTerm))
 
  timeout = .3
  last_event = time.time()
  oks = {my_id}
  debug("Entering wait for quorum achievement")
  while True:   
    for appent in appents.itervalues():
      sock.send(appent)
    last_event = time.time()

    while True: 
      if time.time() - last_event > timeout: break # resend stuff we gotta get quorum!!!
      ready = select.select([sock], [], [], .01)[0]
      if sock in ready:
        msg_raw = sock.recv(32768)
        if len(msg_raw) == 0: continue
        msg = json.loads(msg_raw)
        if msg['type'] != 'appent_res':
          received_buffer.append(msg)
          debug(json.dumps(received_buffer))
          continue

        if msg['commitIndex'] == commitIndex and msg['success']:
          last_event = time.time()
          debug("Received response")
          appents.pop(msg['src'], None)
          oks.add(msg['src'])
          nextIndex[msg['src']] = msg['commitIndex'] + 1
          matchIndex[msg['src']] = msg['lastApplied']
        
          if len(oks) > (cluster_size / 2):
            # yee haw
            lastApplied = len(log) - 1
            return True
        else:
          nextIndex[msg['src']] = msg['commitIndex'] + 1
          matchIndex[msg['src']] = msg['lastApplied']
          if appents.get(msg['src']):
            rid = msg['src'] 
            entries = log[nextIndex[rid]:] 
            prevLogIndex = nextIndex[rid] - 1
            prevLogTerm = 0 if prevLogIndex is -1 else log[prevLogIndex]['term']
            appents[rid] = json.dumps(build_appent(entries, rid, prevLogIndex, prevLogTerm))
    
count = 0
def respond_leader_get_put(msg):
  debug("Handling a get/put as the leader")
  global count, leader, my_id, kvstore, currentTerm

  response = {}
  response['src'] = my_id
  response['dst'] = msg['src']
  response['leader'] = leader
  response['type'] = 'ok'
  response['MID'] = msg['MID']

  if msg['type'] == 'get':
    val = kvstore.get(msg['key'])
    response['value'] = "" if val is None else val
    return sock.send(json.dumps(response))
  elif msg['type'] == 'put':
    count = count + 1
    debug(str(count))
    # naive not-really-consensus-implementation
    log.append({'key': msg['key'], 'value': msg['value'], 'term': currentTerm})
    commitIndex = len(log) - 1
    if send_to_replicas(msg['key'], msg['value']):
      kvstore[msg['key']] = msg['value']
      return sock.send(json.dumps(response))
    else:
      # should probably do something
      return 

def respond_get_put(msg):
  debug("Responding to a get or a put")
  global received_buffer, is_leader, leader, sock
  if leader == 'FFFF':
    received_buffer.append(msg)
    return
  if is_leader:
    return respond_leader_get_put(msg)
  debug("Responding with redirect")
  response = {}
  response['src'] = my_id
  response['dst'] = msg['src']
  response['leader'] = leader
  response['type'] = 'redirect'
  response['MID'] = msg['MID']
  return sock.send(json.dumps(response))

# respond to the provided msg with a failure message
def respond_with_fail(msg):
  debug("Responding with fail")
  response = {}
  response['src'] = my_id
  response['dst'] = msg['src']
  response['leader'] = msg['leader']
  response['type'] = 'fail'
  response['MID'] = msg['MID']
  response_raw = json.dumps(response)
  return sock.send(response_raw)

# handle append entries
def handle_append_entries(msg):
  debug("Handling append entries")
  global log, commitIndex, kvstore, currentTerm, leader, lastApplied, last_leader_msg
  
  last_leader_msg = time.time()
  debug(json.dumps(msg)) 
  res = {}
  res['src'] = my_id
  res['dst'] = msg['src']
  res['type'] = 'appent_res'
  ## do something
  if msg['term'] < currentTerm or (len(msg['entries']) > 0 and msg['prevLogIndex'] > -1 and (len(log) <= msg['prevLogIndex'] or log[msg['prevLogIndex']]['term'] != msg['prevLogTerm'])):
    res['leader'] = leader
    res['term'] = currentTerm
    res['success'] = False
    res['commitIndex'] = commitIndex
    res['lastApplied'] = lastApplied
    return sock.send(json.dumps(res))
  elif len(msg['entries']) == 0:
    # heartbeat
    leader = msg['leader']
    res['commitIndex'] = commitIndex
    res['lastApplied'] = lastApplied
    res['leader'] = leader
    res['term'] = currentTerm
    res['success'] = True
    return sock.send(json.dumps(res))
  else:
    log_index = msg['prevLogIndex'] + 1
    if len(log) > log_index:
      log = log[0:log_index - 1]
    for entry in msg['entries']:
      kvstore[entry['key']] = entry['value']
      log.append(entry)
    
    commitIndex = min(msg['leaderCommit'], len(log) - 1)
    
    # apply everything up to and including prevLogIndex
    for i in range(lastApplied + 1, msg['prevLogIndex'] + 1):
      kvstore[log[i]['key']] = log[i]['value']
    lastApplied = msg['prevLogIndex']

    leader = msg['leader']
    currentTerm = msg['term']
    res['term'] = currentTerm
    res['success'] = True
    res['leader'] = leader
    res['commitIndex'] = commitIndex
    res['lastApplied'] = lastApplied
    return sock.send(json.dumps(res))


# request a vote
def request_vote(rid):
  debug("Requesting vote from" + str(rid))
  req = {}
  req['src'] = my_id
  req['dst'] = rid
  req['type'] = 'reqvot'
  req['leader'] = 'FFFF'
  req['term'] = currentTerm
  req['candidateId'] = my_id
  req['lastLogIndex'] = len(log) - 1
  req['lastLogTerm'] = 0 if len(log) is 0 else log[req['lastLogIndex']]['term']
  req_raw = json.dumps(req)
  sock.send(req_raw)

# begin election
def begin_election():
  debug("Beginning election")
  global currentTerm, votedFor, votesReceived, is_holding_election, last_leader_msg, election_timeout
  currentTerm = currentTerm + 1
  election_timeout = et()
  votedFor[currentTerm] = my_id
  votesReceived = [my_id]
  is_holding_election = True
  last_leader_msg = time.time() 
  for rid in replica_ids:
    request_vote(rid)

# is the received request for vote up to date??
def is_up_to_date(cand_msg):
  global currentTerm, log
  return cand_msg['lastLogTerm'] > currentTerm or cand_msg['lastLogIndex'] >= len(log) - 1

# handle request vote
def handle_request_vote(msg):
  debug("Received request for vote from " + str(msg['src'])) 
  global votedFor, currentTerm, last_leader_msg, election_timeout
  res = {}
  res['src'] = my_id
  res['dst'] = msg['src']
  res['type'] = 'reqvot_res'
  res['leader'] = 'FFFF'
  if msg['term'] < currentTerm:
    res['voteGranted'] = False
  elif votedFor.get(currentTerm, None) in [None, msg['candidateId']] and is_up_to_date(msg):
    election_timeout = et()
    #  initial election case  | every other election  TODO: check log matching
    if ((currentTerm == 0) or (msg['term'] >= currentTerm)): 
      res['voteGranted'] = True
      votedFor[currentTerm] = msg['src']
    else:
      res['voteGranted'] = False
  else:
    res['voteGranted'] = False

  res['term'] = currentTerm
  last_leader_msg = time.time()
  return sock.send(json.dumps(res))

def send_heartbeat():
  debug("Sending heartbeat")
  global my_id, leader, currentTerm, replica_ids, sock, last_heartbeat, votedFor
  htbt = {}
  htbt['src'] = my_id
  htbt['leader'] = leader
  htbt['type'] = 'appent'
  htbt['entries'] = []
  htbt['term'] = currentTerm
  for rid in replica_ids:
    htbt['dst'] = rid
    sock.send(json.dumps(htbt))
  last_heartbeat = time.time()
  return

def handle_vote_received(msg):
  debug('Received vote from ' + str(msg['src']))
  global leader, is_leader, my_id, votesReceived, is_holding_election
  if not is_holding_election or not msg['voteGranted']:
    return
  votesReceived.append(msg['src'])
  if len(votesReceived) > (cluster_size / 2):
    debug("I've won the election")
    # we won the election! 
    # send a heartbeat 
    leader = my_id
    is_leader = True
    votesReceived = []
    is_holding_election = False
    for rid in replica_ids:
      nextIndex[rid] = len(log)
      matchIndex[rid] = -1
    send_heartbeat() 

def retry_appents():
  global replica_ids, nextIndex, matchIndex, log, commitIndex, sock
  for rid in replica_ids:
    debug('here')
    # for each replica, send what we think they don't have
    # what we think they don't have is everything past lastIndex[rid] inclusive
    if nextIndex[rid] >= commitIndex: continue
    entries_to_send = get_entries(rid)
    
    appent = build_appent(entries_to_send, rid, nextIndex - 1, 0 if nextIndex == 0 else log[nextIndex - 1]['term'])
    appent_raw = json.dumps(appent)
    debug(str(len(appent_raw)), force=True)

    sock.send(appent_raw)
 
def handle_appent_res(msg):
  global nextIndex, matchIndex
  rid = msg['src']
  nextIndex[rid] = msg['commitIndex']
  matchIndex[rid] = msg['lastApplied']
  return
 
######################################
############## event loop ############
######################################

debug("Election Timeout " + str(election_timeout))


def receive_message(sock):
  ready = select.select([sock], [], [], 0.01)[0]
  msg = None
  if sock in ready:
    msg_raw = sock.recv(32768)
    if len(msg_raw) == 0: return None
    msg = json.loads(msg_raw)

  if msg is not None:
    if msg['dst'] != str(my_id): 
      debug('Message not for me')
      return None

  return msg

while True:

  if is_leader and time.time() - last_heartbeat > heartbeat_timeout:
    send_heartbeat()	

  # keep trying to get ahold of our MIA followers
  if is_leader:
    retry_appents()

  msg = None
  if leader != 'FFFF' and len(received_buffer) != 0:
    debug(json.dumps(received_buffer))
    debug(str(leader))
    msg = received_buffer.pop(0)
  else:
    msg = receive_message(sock)

  if msg is None:
    continue	 

  if msg['type'] in ['get', 'put']:
    respond_get_put(msg)
  elif msg['type'] == 'appent':
    handle_append_entries(msg)
    last_leader_msg = time.time()
  elif msg['type'] == 'appent_res':
    handle_appent_res(msg)
  elif msg['type'] == 'reqvot':
    handle_request_vote(msg)
  elif msg['type'] == 'reqvot_res':
    handle_vote_received(msg)
      
		
  clock = time.time()
  # if election timeout has occurred
  if not is_leader and (clock - last_leader_msg) > election_timeout:
    begin_election()
    last = clock

"""
keep track of what our followers know and retry sending them stuff they don't know

handle appent_res as leader
"""
