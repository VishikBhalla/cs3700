#!/usr/bin/env python

import sys, socket, select, time, json, random

######################################
######## pre-loop definitions ########
######################################

# cluster size
cluster_size = len(sys.argv) - 1

# Your ID number
my_id = sys.argv[1]

# The ID numbers of all the other replicas
replica_ids = sys.argv[2:]

# get pretty colors for printing
colors = []
for i in range(256):
  colors.append(u"\u001b[38;5;" + str(i) + "m")
sorted_ids = sorted(sys.argv[1:])
my_color = colors[(1 + sorted_ids.index(my_id)) % 256]


# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
sock.connect(my_id)


DEBUG = False


######################################
######## function definitions ########
######################################

init_time = time.time()

def debug(msg, **kwargs):
  if DEBUG or kwargs.get("force") :
    clock = time.time()
    print(my_color + "Replica " + str(my_id) + " :: " + str(clock) + " (" + str(clock-init_time) + ") :: " + msg + '\033[0m')


# helpers and constants for all replicas
def et():
  return random.uniform(0.1, 0.3)

current_term = 0
voted_for = dict() # map from term -> rid
log = [{'term': 0}]
commit_index = 0
last_applied = 0
election_timeout = et()
last_event = time.time()
leader = 'FFFF'
kvstore = dict()

def add_headers(msg, dst, typ):
  global my_id, leader
  msg['dst'] = dst
  msg['src'] = my_id
  msg['leader'] = leader
  msg['type'] = typ
  return msg


# helpers and constants for leader replicas
next_index = dict() # map from rid to log index
match_index = dict() # map from rid to log index
rep_timeouts = dict()
LEAD = 'leader'
CAND = 'candidate'
FOLL = 'follower'
my_role = FOLL
waiting_put = None
waiting_put_mid = None
waiting_put_confirms = set()
waiting_timestamp = time.time()
retry_timeout = 0.1

# helpers and constants for candidate replicas
received_votes = set()

# buffers 
reqvot_buffer = {} # requested votes buffer to send, mapping from rid to raw json msg
received_buffer = [] # items received but not acted upon yet
client_response_buffer = [] # responses that need to be sent to the client
replica_response_buffer = [] # responses that need to be sent to other replicas

# election cycle
def abdicate(new_term, new_leader):
  debug('Abdicating!')
  global last_event, next_index, match_index, rep_timeouts, my_role, current_term, leader, waiting_put, waiting_put_mid, waiting_put_confirms
  current_term = new_term   
  leader = new_leader
  next_index = dict()
  match_index = dict()
  rep_timeouts = dict()
  my_role = FOLL
  last_event = time.time()
  # redirect waiting put
  if waiting_put is not None:
    redirect(waiting_put)
  waiting_put = None
  waiting_put_mid = None
  waiting_put_confirms = set()
  return

def bow_out(new_term, new_leader):
  debug('Bowing out!')
  global current_term, received_votes, my_role, leader, reqvot_buffer
  my_role = FOLL
  current_term = new_term
  leader = new_leader
  reqvot_buffer = {}
  last_event = time.time()
  received_votes = set()
  return

def nominate():
  debug('Nominating myself!')
  global my_role, voted_for, last_event, retry_timeout, received_votes, current_term, election_timeout, replica_ids, my_id, reqvot_buffer
  my_role = CAND 
  current_term = current_term + 1
  election_timeout = et()
  last_event = time.time()
  voted_for[current_term] = my_id
  received_votes = set([my_id])
  for rid in replica_ids:
    rep_timeouts[rid] = {'to': retry_timeout, 'last': 0}
    req = {'term': current_term, 'candidateId': my_id, 'lastLogIndex': len(log) - 1, 'lastLogTerm': log[-1]['term']}
    req = add_headers(req, rid, 'reqvot')
    reqvot_buffer[rid] = json.dumps(req)
  return

def inaugurate():
  debug('Inaugurating myself!')
  global leader, my_role, rep_timeouts, match_index, retry_timeout, reqvot_buffer, next_index, replica_ids, my_id, log, commit_index
  my_role = LEAD
  leader = my_id
  reqvot_buffer = {}
  received_votes = set()
  for rid in replica_ids:
    rep_timeouts[rid] = {'to': retry_timeout, 'last': 0}
    next_index[rid] = len(log)
    match_index[rid] = 0
    req = {'term': current_term, 'leaderId': leader, 'prevLogIndex': 0, 'prevLogTerm': 0, 'entries': [], 'leaderCommit': commit_index}
    req = add_headers(req, rid, 'appent')
  return

# message handling
def redirect(msg):
  global my_id, client_response_buffer
  resp = {'MID': msg['MID']}
  resp = add_headers(resp, my_id, 'redirect')
  return client_response_buffer.append(json.dumps(resp))

def leader_get_put(msg):
  global log, replica_ids, waiting_timestamp, kvstore, my_id, client_response_buffer, current_term, waiting_put, waiting_put_confirms, waiting_put_mid, rep_timeouts
  if msg['type'] == 'get':
    value = kvstore.get(msg['key'], "")
    resp = {'value': value, 'MID': msg['MID']}
    resp = add_headers(resp, msg['src'], 'ok')
    return client_response_buffer.append(json.dumps(resp))
  else:
    new_entry = {'key': msg['key'], 'value': msg['value'], 'term': current_term}
    log.append(new_entry)
    for repto in rep_timeouts.itervalues():
      repto['last'] = 0
    waiting_put = msg
    waiting_put_mid = msg['MID']
    waiting_put_confirms = set([my_id])
    waiting_timestamp = time.time()
    return
    
def build_appent(rid):
  global current_term, log, next_index, commit_index, leader, waiting_put_mid
  appent = {'term': current_term, 'leaderId': leader, 'prevLogIndex': next_index[rid] - 1, 'prevLogTerm': log[next_index[rid] - 1]['term'], 'leaderCommit': commit_index}
  entries = [] if next_index[rid] >= len(log) else log[next_index[rid]:]
  if len(entries) > 100:
    entries = entries[0:100]
  elif waiting_put_mid is not None:
    appent['forMID'] = waiting_put_mid
  appent['entries'] = entries
  appent = add_headers(appent, rid, 'appent')
  return json.dumps(appent)

# io

def receive_message(sock):
  ready = select.select([sock], [], [], 0.000001)[0]
  msg = None
  if sock in ready:
    msg_raw = sock.recv(32768)
    if len(msg_raw) == 0: return None
    msg = json.loads(msg_raw)
  return msg

def send_message(sock, msg):
  return sock.send(msg)

def read_all(sock):
  global received_buffer
  while True:
    msg = receive_message(sock)
    if msg is None:
      return
    else: 
      received_buffer.append(msg)
    

  

def is_log_current(lastLogTerm, lastLogIndex):
  global log
  my_last_term = log[-1]['term']
  if lastLogTerm > my_last_term:
    return True
  elif lastLogTerm < my_last_term:
    return False
  else: 
    return lastLogIndex >= len(log) - 1

# process functions for each role
def process_buff_foll():
  global kvstore, commit_index, last_applied, leader, client_response_buffer, log, replica_response_buffer, received_buffer, reqvot_buffer, received_votes, voted_for, current_term, cluster_size, last_event
  if len(received_buffer) == 0: return

  remainder = []
  while len(received_buffer) > 0:
    msg = received_buffer.pop(0)

    if msg['type'] in ['get', 'put']:
      if leader == 'FFFF':
        remainder.append(msg) # deal with it later
      else:
        resp = {'MID': msg['MID']}
        resp = add_headers(resp, msg['src'], 'redirect')
        client_response_buffer.append(json.dumps(resp))

    elif msg['type'] == 'appent':
      last_event = time.time()
      if msg['term'] < current_term or msg['prevLogIndex'] >= len(log) or msg['prevLogTerm'] != log[msg['prevLogIndex']]['term']:
        resp = {'term': current_term, 'success': False, 'nextIndex': commit_index}
        if msg.get('forMID'): 
          resp['forMID'] = msg['forMID']
        resp = add_headers(resp, msg['src'], 'appent_res')
        replica_response_buffer.append(json.dumps(resp))
      else: # we can append
        leader = msg['leader']
        current_term = msg['term']
        if len(msg['entries']) > 0: # but we only want to modify the log if its not simply a heartbeat
          log = log[0:msg['prevLogIndex']+1]
          for entry in msg['entries']:
            log.append(entry)
        if msg['leaderCommit'] > commit_index:
          commit_index = min(msg['leaderCommit'], len(log) - 1)
          debug("Committed to " + str(commit_index) + str(leader), force=True)
          while commit_index > last_applied:
            last_applied = last_applied+1
            kvstore[log[last_applied]['key']] = log[last_applied]['value']
        resp = {'term': current_term, 'success': True, 'nextIndex': len(log)}
        if msg.get('forMID'):
          resp['forMID'] = msg['forMID']
        resp = add_headers(resp, msg['src'], 'appent_res')
        replica_response_buffer.append(json.dumps(resp))

    elif msg['type'] == 'reqvot':
      debug('Received request for vote from ' + str(msg['src']))
      if msg['term'] < current_term:
        resp = {'term': current_term, 'voteGranted': False}
        resp = add_headers(resp, msg['src'], 'reqvot_res')
        replica_response_buffer.append(json.dumps(resp))
      else:
        current_term = msg['term']
        leader = 'FFFF' # we must have moved onto a new term, so we don't know who the leader is!
        if voted_for.get(current_term, msg['candidateId']) == msg['candidateId'] and is_log_current(msg['lastLogTerm'], msg['lastLogIndex']):
          debug('Granting')
          voted_for[current_term] = msg['candidateId']
          resp = {'voteGranted': True, 'term': current_term}
          resp = add_headers(resp, msg['src'], 'reqvot_res')
          client_response_buffer.append(json.dumps(resp))
        else:
          resp = {'voteGranted': False, 'term': current_term}
          resp = add_headers(resp, msg['src'], 'reqvot_res')
          client_response_buffer.append(json.dumps(resp))

    elif msg['type'] in ['reqvot_res', 'appent_res']:
      if msg['term'] > current_term:
        leader = msg['leader']

  received_buffer = remainder

def process_buff_lead():
  global next_index, match_index, kvstore, rep_timeouts, commit_index, last_applied, leader, client_response_buffer, log, replica_response_buffer, received_buffer, reqvot_buffer, received_votes, voted_for, current_term, cluster_size, waiting_put, waiting_put_mid, waiting_put_confirms
  
  if len(received_buffer) == 0: return

  remainder = []
  while len(received_buffer) > 0:
    msg = received_buffer.pop(0)
    
    if msg['type'] in ['get', 'put']:
      if waiting_put is not None:
        remainder.append(msg)
      else:
        leader_get_put(msg)
    
    elif msg['type'] == 'appent':
      if msg['term'] > current_term:
        abdicate(msg['term'], msg['leader'])
        received_buffer = remainder + [msg] + received_buffer
        return process_buff_foll()
      else:
        resp = {'term': current_term, 'success': False}
        resp = add_headers(resp, msg['src'], 'appent_res')
        replica_response_buffer.append(json.dumps(resp))

    elif msg['type'] == 'appent_res':
      rep_timeouts[msg['src']]['last'] = time.time()
      if msg['term'] > current_term:
        abdicate(msg['term'], msg['leader'])
        received_buffer = remainder + received_buffer
        return process_buff_foll()
      elif msg['success'] == False:
        next_index[msg['src']] = msg['nextIndex'] # we failed an eppent, so set the next index to what the replica told us to (minus 1 currently)
      else:
        next_idx_temp = min(msg['nextIndex'], len(log))
        next_index[msg['src']] = next_idx_temp
        match_index[msg['src']] = next_idx_temp - 1 # we know everything up until the next index is replicated
        if waiting_put_mid is not None:
          if msg.get('forMID') == waiting_put_mid:
            waiting_put_confirms.add(msg['src'])
            if len(waiting_put_confirms) > (cluster_size / 2.0):              
              debug("Leader committing log idx " + (str(commit_index + 1)) + str(leader), force=True)
              commit_index = commit_index + 1
              last_applied = commit_index
              kvstore[waiting_put['key']] = waiting_put['value']
              resp = {'MID': waiting_put_mid}
              resp = add_headers(resp, waiting_put['src'], 'ok')
              client_response_buffer.append(json.dumps(resp))
              waiting_put = None
              waiting_put_mid = None
              waiting_put_confirms = set()        

    elif msg['type'] == 'reqvot':
      if msg['term'] > current_term:
        abdicate(msg['term'], msg['leader'])
        received_buffer = remainder + [msg] + received_buffer
        return process_buff_foll()
      else:
        resp = {'term': current_term, 'voteGranted': False}
        resp = add_headers(resp, msg['src'], 'reqvot_res')
        replica_response_buffer.append(json.dumps(resp))
    
    elif msg['type'] == 'reqvot_res':
      if msg['term'] > current_term:
        abdicate(msg['term'], msg['leader'])
        received_buffer = remainder + received_buffer
        return process_buff_foll()

  received_buffer = remainder


def process_buff_cand():
  global last_event, plica_response_buffer, received_buffer, reqvot_buffer, received_votes, voted_for, current_term, cluster_size
  if len(received_buffer) == 0: return

  remainder = []
  while len(received_buffer) > 0:
    msg = received_buffer.pop(0)
    
    if msg['type'] == 'reqvot_res':
      debug('Received vote from ' + str(msg['src']) + " " + str(msg['voteGranted']))
      
      if msg['term'] > current_term:
        bow_out(msg['term'], msg['leader'])
        received_buffer = remainder + received_buffer
        return process_buff_foll() # convert to follower    
      if msg['term'] == current_term and msg['voteGranted'] == True:
        received_votes.add(msg['src'])
        if msg['src'] in reqvot_buffer:
          reqvot_buffer.pop(msg['src'])
        if len(received_votes) > (cluster_size / 2):
          inaugurate()
          received_buffer = remainder + received_buffer
          return process_buff_lead() # convert to leader and co        
  
    elif msg['type'] == 'reqvot':
      debug("Received request for vote from " + str(msg['src']))
      
      if msg['term'] > current_term:
        bow_out(msg['term'], msg['leader'])
        # don't deal with actually voting, let the follower function handle that
        received_buffer = remainder + [msg] + received_buffer
        return process_buff_foll() # convert to follower
      else:
        resp = {'term': current_term, 'voteGranted': False}
        resp = add_headers(resp, msg['src'], 'reqvot_res')
        replica_response_buffer.append(json.dumps(resp))

    elif msg['type'] == 'appent':

      if msg['term'] >= current_term:
        bow_out(msg['term'], msg['leader'])
        received_buffer = remainder + [msg] + received_buffer
        return process_buff_foll()
      else:
        resp = {'term': current_term, 'success': False}
        resp = add_headers(resp, msg['src'], 'appent_res')
        replica_response_buffer.append(json.dumps(resp))

    elif msg['type'] == 'appent_res':
      if msg['term'] >= current_term:
        bow_out(msg['term'], msg['leader'])
        received_buffer = remainder + received_buffer
        return process_buff_foll() 
    
    elif msg['type'] in ['get', 'put']: # add gets and puts to remainder, but this might cause a latency spike? maybe should redirect?
      remainder.append(msg)

  received_buffer = remainder

# event loop
while True:
  # always respond to clients if you can
  for msg in client_response_buffer:
    send_message(sock, msg)
  client_response_buffer = []

  # always respond to other replicas if you can
  for msg in replica_response_buffer:
    send_message(sock, msg)
  replica_response_buffer = []
 
  # send
  if my_role == CAND:
    clock = time.time()
    for rid in replica_ids:
      if (clock - rep_timeouts[rid]['last'] > rep_timeouts[rid]['to']) and reqvot_buffer.get(rid): # send reqvot
        send_message(sock, reqvot_buffer[rid])
        rep_timeouts[rid]['last'] = clock
  elif my_role == LEAD:
    clock = time.time()
    for rid in replica_ids:
      if (clock - rep_timeouts[rid]['last'] > rep_timeouts[rid]['to']):
        send_message(sock, build_appent(rid))
        rep_timeouts[rid]['last'] = clock
  #elif my_role == FOLL:
    # no special things to send if you're a follower! just listen and respond!    

  # receive
  read_all(sock)
  
  # process
  if my_role == CAND:
    process_buff_cand()
  elif my_role == LEAD:
    process_buff_lead()
  elif my_role == FOLL:
    process_buff_foll()

  # timeout test
  if my_role != LEAD and time.time() - last_event > election_timeout:
   nominate()



