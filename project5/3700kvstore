#!/usr/bin/env python

import sys, socket, select, time, json, random

######################################
######## pre-loop definitions ########
######################################

# cluster size
cluster_size = len(sys.argv) - 1

# Your ID number
my_id = sys.argv[1]

# The ID numbers of all the other replicas
replica_ids = sys.argv[2:]

# get pretty colors for printing
colors = []
for i in range(256):
  colors.append(u"\u001b[38;5;" + str(i) + "m")
sorted_ids = sorted(sys.argv[1:])
my_color = colors[(1 + sorted_ids.index(my_id)) % 256]


# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
sock.connect(my_id)

last_leader_msg = time.time()
is_leader = False

def et():
  return random.uniform(0.2, 0.5)

election_timeout = et()

leader = 'FFFF'

currentTerm = 0
votedFor = {}
votesReceived = []
is_holding_election = False

log = []

commitIndex = -1
lastApplied = -1

# leader state
nextIndex = {} 
matchIndex = {} #lastapplieds

heartbeat_timeout = 0.1
last_heartbeat = time.time()

kvstore = {}

DEBUG = False

received_buffer = []


timeouts = dict()
for rid in replica_ids:
  timeouts[rid] = dict()    
  timeouts[rid]['to'] = 0.3
  timeouts[rid]['last'] = 0

######################################
######## function definitions ########
######################################

init_time = time.time()

def debug(msg, **kwargs):
  if DEBUG :
#or kwargs.get("force") :
    clock = time.time()
    print(my_color + "Replica " + str(my_id) + " :: " + str(clock) + " (" + str(clock-init_time) + ") :: " + msg + '\033[0m')

debug("", force=True)

def build_appent(entries, dst, prevLogIndex, prevLogTerm):
  global my_id, sock, received_buffer, leader, currentTerm, replica_ids, sock, last_heartbeat, votedFor
  htbt = {}
  htbt['src'] = my_id
  htbt['dst'] = dst
  htbt['leader'] = leader
  htbt['type'] = 'appent'
  htbt['entries'] = entries
  htbt['term'] = currentTerm
  htbt['prevLogIndex'] = prevLogIndex
  htbt['prevLogTerm'] = prevLogTerm
  htbt['leaderCommit'] = commitIndex
  return htbt
  
def get_entries(rid):
  global log, nextIndex
  return log[nextIndex[rid]:][0:100] 

def send_to_replicas(key, val):
  debug("Sending appent to replicas")
  global my_id, sock, received_buffer, leader, commitIndex, currentTerm, nextIndex, log, replica_ids, sock, last_heartbeat, votedFor
  
  appents = dict()
  for rid in replica_ids:
    entries = get_entries(rid)
    prevLogIndex = nextIndex[rid] - 1
    prevLogTerm = 0 if (prevLogIndex >= len(log) or prevLogIndex == -1) else log[prevLogIndex]['term']
    appents[rid] = json.dumps(build_appent(entries, rid, prevLogIndex, prevLogTerm))
 
  timeout = .3
  last_event = time.time()
  oks = {my_id}
  debug("Entering wait for quorum achievement")
  while True:   
    for appent in appents.itervalues():
      sock.send(appent)
    last_event = time.time()

    while True: 
      if time.time() - last_event > timeout: break # resend stuff we gotta get quorum!!!
      ready = select.select([sock], [], [], .01)[0]
      if sock in ready:
        msg_raw = sock.recv(32768)
        if len(msg_raw) == 0: continue
        msg = json.loads(msg_raw)
        if msg['type'] != 'appent_res':
          received_buffer.append(msg)
          debug(json.dumps(received_buffer))
          continue

        if msg['commitIndex'] == commitIndex and msg['success']:
          last_event = time.time()
          debug("Received response")
          appents.pop(msg['src'], None)
          oks.add(msg['src'])
          nextIndex[msg['src']] = msg['commitIndex'] + 1
          matchIndex[msg['src']] = msg['lastApplied']
        
          if len(oks) > (cluster_size / 2):
            # yee haw
            lastApplied = len(log) - 1
            return True
        else:
          nextIndex[msg['src']] = msg['commitIndex'] + 1
          matchIndex[msg['src']] = msg['lastApplied']
          if appents.get(msg['src']):
            rid = msg['src'] 
            entries = log[nextIndex[rid]:] 
            prevLogIndex = nextIndex[rid] - 1
            if prevLogIndex >= len(log):
              debug("PrevLogIndex too big ! " + str(prevLogIndex) +" >= " + str(len(log)), force=True)
            prevLogTerm = 0 if prevLogIndex == -1 else log[prevLogIndex]['term']
            appents[rid] = json.dumps(build_appent(entries, rid, prevLogIndex, prevLogTerm))
    
count = 0
def respond_leader_get_put(msg):
  debug("Handling a get/put as the leader", force=True)
  global count, leader, my_id, kvstore, currentTerm, commitIndex

  response = {}
  response['src'] = my_id
  response['dst'] = msg['src']
  response['leader'] = leader
  response['type'] = 'ok'
  response['MID'] = msg['MID']

  if msg['type'] == 'get':
    val = kvstore.get(msg['key'])
    response['value'] = "" if val is None else val
    return sock.send(json.dumps(response))
  elif msg['type'] == 'put':
    count = count + 1
    debug(str(count))
    # naive not-really-consensus-implementation
    log.append({'key': msg['key'], 'value': msg['value'], 'term': currentTerm})
    commitIndex = len(log) - 1
    if send_to_replicas(msg['key'], msg['value']):
      kvstore[msg['key']] = msg['value']
      return sock.send(json.dumps(response))
    else:
      # should probably do something
      return 

def respond_get_put(msg):
  debug("Responding to a get or a put")
  global received_buffer, is_leader, leader, sock
  if leader == 'FFFF':
    received_buffer.append(msg)
    return
  if is_leader:
    return respond_leader_get_put(msg)
  debug("Responding with redirect to " + str(leader), force=True)
  response = {}
  response['src'] = my_id
  response['dst'] = msg['src']
  response['leader'] = leader
  response['type'] = 'redirect'
  response['MID'] = msg['MID']
  return sock.send(json.dumps(response))

# respond to the provided msg with a failure message
def respond_with_fail(msg):
  debug("Responding with fail")
  response = {}
  response['src'] = my_id
  response['dst'] = msg['src']
  response['leader'] = msg['leader']
  response['type'] = 'fail'
  response['MID'] = msg['MID']
  response_raw = json.dumps(response)
  return sock.send(response_raw)

# handle append entries
def handle_append_entries(msg):
  debug("Handling append entries")
  global log, commitIndex, kvstore, currentTerm, leader, lastApplied, last_leader_msg
  
  last_leader_msg = time.time()
  debug(json.dumps(msg)) 
  res = {}
  res['src'] = my_id
  res['dst'] = msg['src']
  res['type'] = 'appent_res'
  ## do something
  if msg['term'] < currentTerm or (len(msg['entries']) > 0 and msg['prevLogIndex'] > -1 and (len(log) <= msg['prevLogIndex'] or log[msg['prevLogIndex']]['term'] != msg['prevLogTerm'])):
    res['leader'] = leader
    res['term'] = currentTerm
    res['success'] = False
    res['commitIndex'] = commitIndex
    res['lastApplied'] = lastApplied
    return sock.send(json.dumps(res))
  elif len(msg['entries']) == 0:
    # heartbeat
    leader = msg['leader']
    res['commitIndex'] = commitIndex
    res['lastApplied'] = lastApplied
    res['leader'] = leader
    res['term'] = currentTerm
    res['success'] = True
    return sock.send(json.dumps(res))
  else:
    log_index = msg['prevLogIndex'] + 1
    if len(log) > log_index:
      log = log[0:log_index - 1]
    for entry in msg['entries']:
      kvstore[entry['key']] = entry['value']
      log.append(entry)
    
    commitIndex = min(msg['leaderCommit'], len(log) - 1)
    
    # apply everything up to and including prevLogIndex
    for i in range(lastApplied + 1, msg['prevLogIndex'] + 1):
      kvstore[log[i]['key']] = log[i]['value']
    lastApplied = msg['prevLogIndex']

    leader = msg['leader']
    currentTerm = msg['term']
    res['term'] = currentTerm
    res['success'] = True
    res['leader'] = leader
    res['commitIndex'] = commitIndex
    res['lastApplied'] = lastApplied
    return sock.send(json.dumps(res))


# request a vote
def request_vote(rid):
  debug("Requesting vote from" + str(rid))
  req = {}
  req['src'] = my_id
  req['dst'] = rid
  req['type'] = 'reqvot'
  req['leader'] = 'FFFF'
  req['term'] = currentTerm
  req['candidateId'] = my_id
  req['lastLogIndex'] = len(log) - 1
  req['lastLogTerm'] = 0 if len(log) is 0 else log[req['lastLogIndex']]['term']
  req_raw = json.dumps(req)
  sock.send(req_raw)

# begin election
def begin_election():
  global leader, currentTerm, votedFor, votesReceived, is_holding_election, last_leader_msg, election_timeout
  
  currentTerm = currentTerm + 1
  debug("Beginning election " + str(currentTerm), force=True)
  election_timeout = et()
  votedFor[currentTerm] = my_id
  votesReceived = [my_id]
  is_holding_election = True
  last_leader_msg = time.time() 
  leader = 'FFFF'
  for rid in replica_ids:
    request_vote(rid)

# is the received request for vote up to date??
def is_up_to_date(cand_msg):
  global currentTerm, log
  return cand_msg['lastLogTerm'] > currentTerm or cand_msg['lastLogIndex'] >= len(log) - 1

# handle request vote
def handle_request_vote(msg):
  debug("Received request for vote from " + str(msg['src'])) 
  global votedFor, leader, currentTerm, last_leader_msg, election_timeout
  res = {}
  res['src'] = my_id
  res['dst'] = msg['src']
  res['type'] = 'reqvot_res'
  if msg['term'] < currentTerm:
    res['voteGranted'] = False
  elif votedFor.get(currentTerm, None) in [None, msg['candidateId']] and is_up_to_date(msg):
    election_timeout = et()
    res['voteGranted'] = True
    votedFor[currentTerm] = msg['src']
    leader = 'FFFF'
  else:
    res['voteGranted'] = False

  res['leader'] = leader
  res['term'] = currentTerm
  last_leader_msg = time.time()
  return sock.send(json.dumps(res))

def send_heartbeat():
  debug("Sending heartbeat", force=True)
  global my_id, leader, currentTerm, replica_ids, sock, last_heartbeat, votedFor
  htbt = {}
  htbt['src'] = my_id
  htbt['leader'] = leader
  htbt['type'] = 'appent'
  htbt['entries'] = []
  htbt['term'] = currentTerm
  for rid in replica_ids:
    if time.time() - timeouts[rid]['last'] > timeouts[rid]['to']:
      htbt['dst'] = rid
      sock.send(json.dumps(htbt))
      timeouts[rid]['last'] = time.time()
  return

def handle_vote_received(msg):
  global leader, is_leader, my_id, votesReceived, is_holding_election, replica_ids
  if not is_holding_election or not msg['voteGranted']:
    return
  else:
    debug("I've won the election "+str(currentTerm), force=True)
    # we won the election! 
    # send a heartbeat 
    leader = my_id
    is_leader = True
    votesReceived = []
    is_holding_election = False
    for rid in replica_ids:
      nextIndex[rid] = len(log)
      matchIndex[rid] = -1
    send_heartbeat() 

def retry_appents():
  global replica_ids, nextIndex, matchIndex, log, commitIndex, sock, timeouts
  for rid in replica_ids:
    if time.time() - timeouts[rid]['last'] < timeouts[rid]['to']: continue
    # for each replica, send what we think they don't have
    # what we think they don't have is everything past lastIndex[rid] inclusive
    if nextIndex[rid] >= commitIndex or nextIndex[rid] >= len(log): continue
    entries_to_send = get_entries(rid)
    
    appent = build_appent(entries_to_send, rid, nextIndex[rid] - 1, 0 if nextIndex[rid] == 0 else log[nextIndex[rid]]['term'])
    appent_raw = json.dumps(appent)
    sock.send(appent_raw)
    timeouts[rid]['last'] = time.time()
 
def handle_appent_res(msg):
  global nextIndex, matchIndex
  rid = msg['src']
  nextIndex[rid] = msg['commitIndex']
  matchIndex[rid] = msg['lastApplied']
  return
 
######################################
############## event loop ############
######################################

debug("Election Timeout " + str(election_timeout))


def receive_message(sock):
  ready = select.select([sock], [], [], 0.01)[0]
  msg = None
  if sock in ready:
    msg_raw = sock.recv(32768)
    if len(msg_raw) == 0: return None
    msg = json.loads(msg_raw)

  if msg is not None:
    if msg['dst'] != str(my_id): 
      debug('Message not for me')
      return None

  return msg

while True:

  if is_leader:
    retry_appents()
    send_heartbeat()	


  msg = None
  if leader != 'FFFF' and len(received_buffer) != 0:
    debug(json.dumps(received_buffer), force=True)
    msg = received_buffer.pop(0)
  else:
    msg = receive_message(sock)

  if msg is None:
    continue	 

  if msg['type'] in ['get', 'put']:
    respond_get_put(msg)
  else:
    if msg['term'] > currentTerm:
      if is_leader:
        debug("I'm handing over the keys to the kingdom", force=True)
        debug(json.dumps(received_buffer), force=True)

      is_leader = False
      currentTerm = msg['term']
      leader = msg['leader']
      is_holding_election = False
      votesReceived = [] 
 
    if msg['type'] == 'appent':
      handle_append_entries(msg)
      last_leader_msg = time.time()
    elif msg['type'] == 'appent_res':
      handle_appent_res(msg)
    elif msg['type'] == 'reqvot':
      handle_request_vote(msg)
    elif msg['type'] == 'reqvot_res':
      handle_vote_received(msg)
      
		
  clock = time.time()
  # if election timeout has occurred
  if not is_leader and (clock - last_leader_msg) > election_timeout:
    begin_election()
    last = clock

"""
keep track of what our followers know and retry sending them stuff they don't know

handle appent_res as leader
"""
# helpers and constants for all replicas
def et()
  return random.uniform(0.2, 0.5)

current_term = 0
voted_for = dict() # map from term -> rid
log = [{'term': 0}]
commit_index = 0
last_applied = 0
election_timeout = et()
last_event = time.time()
leader = 'FFFF'
kvstore = dict()

def add_headers(msg, dst, typ):
  global my_id, leader
  msg['dst'] = dst
  msg['src'] = my_id
  msg['leader'] = leader
  msg['type'] = typ
  return msg


# helpers and constants for leader replicas
next_index = dict() # map from rid to log index
match_index = dict() # map from rid to log index
rep_timeouts = dict()
LEAD = 'leader'
CAND = 'candidate'
FOLL = 'follower'
my_role = FOLL
waiting_put = None
waiting_put_mid = None
waiting_put_confirms = set()

# helpers and constants for candidate replicas
received_votes = set()

# buffers 
reqvot_buffer = {} # requested votes buffer to send, mapping from rid to raw json msg
received_buffer = [] # items received but not acted upon yet
client_response_buffer = [] # responses that need to be sent to the client
replica_response_buffer = [] # responses that need to be sent to other replicas

# election cycle
def abdicate(new_term, new_leader):
  global b_appent_buffer, last_event, appent_buffer, next_index, match_index, rep_timeouts, my_role, current_term, leader, waiting_put, waiting_put_mid, waiting_put_confirms
  current_term = new_term   
  leader = new_leader
  next_index = dict()
  match_index = dict()
  rep_timeouts = dict()
  b_appent_buffer = []
  appent_buffer = []
  my_role = FOLL
  last_event = time.time()
  # redirect waiting put
  if waiting_put is not None:
    redirect(waiting_put)
  waiting_put = None
  waiting_put_mid = None
  waiting_put_confirms = set()
  return

def bow_out(new_term, new_leader):
  global current_term, received_votes, my_role, leader, reqvot_buffer
  my_role = FOLL
  current_term = new_term
  leader = new_leader
  reqvot_buffer = {}
  last_event = time.time()
  received_votes = set()
  return

def nominate():
  global my_role, voted_for, last_event, received_votes, current_term, election_timeout, replica_ids, my_id, reqvot_buffer
  my_role = CAND 
  current_term = current_term + 1
  election_timeout = et()
  last_event = time.time()
  voted_for[current_term] = my_id
  received_votes = set([my_id])
  for rid in replica_ids:
    rep_timeouts[rid] = {'to': 0.1, 'last': 0}
    req = {'term': currentTerm, 'candidateId': my_id, 'lastLogIndex': len(log) - 1, 'lastLogTerm': log[-1]['term']}
    req = add_headers(req, rid, 'reqvot')
    regvot_buffer[rid] = json.dumps(req)
  return

def inaugurate():
  global leader, my_role, rep_timeouts, match_index, reqvot_buffer, next_index, replica_ids, my_id, appent_buffer, log, commit_index
  my_role = LEAD
  leader = my_id
  reqvot_buffer = {}
  received_votes = set()
  for rid in replica_ids:
    rep_timeouts[rid] = {'to': 0.1, 'last': 0}
    next_index[rid] = len(log)
    match_index[rid] = 0
    req = {'term': currentTerm, 'leaderId': leader, 'prevLogIndex': 0, 'prevLogTerm': 0, 'entries': [], 'leaderCommit': commit_index}
    req = add_headers(req, rid, 'appent')
    appent_buffer.append(req)
  return

# message handling
def redirect(msg):
  global my_id, client_response_buffer
  resp = {'MID': msg['MID']}
  resp = add_headers(resp, my_id, 'redirect')
  return client_response_buffer.append(json.dumps(resp))

def leader_get_put(msg):
  global log, replica_ids, kvstore, my_id, client_response_buffer, current_term, waiting_put, waiting_put_confirms, waiting_put_mid
  if msg['type'] == 'get':
    value = kvstore.get(msg['key'], "")
    resp = {'value': value, 'MID': msg['MID']}
    resp = add_headers(resp, msg['src'], 'ok')
    return client_response_buffer.append(json.dumps(resp))
  else:
    new_entry = {'key': msg['key'], 'value': msg['value'], 'term': current_term}
    log.append(new_entry)
    waiting_put = msg
    waiting_put_mid = msg['mid']
    waiting_put_confirms = set([my_id])
    return
    
def build_appent(rid):
  global current_term, log, next_index, commit_index, leader, waiting_put_mid
  appent = {'term': current_term, 'leaderId': leader, 'prevLogIndex': next_index[rid] - 1, 'prevLogTerm': log[next_index[rid] - 1], 'leaderCommit': commit_index}
  entries = [] if next_index[rid] >= len(log) else log[next_index[rid]:]
  if len(entries) > 100:
    entries = entries[0:100]
  elif waiting_put_mid is not None:
    appent['forMID'] = waiting_put_mid
  appent['entries'] = entries
  appent = add_headers(appent, rid, 'appent')
  return json.dumps(appent)

# io

def receive_message(sock):
  ready = select.select([sock], [], [], 0.01)[0]
  msg = None
  if sock in ready:
    msg_raw = sock.recv(32768)
    if len(msg_raw) == 0: return None
    msg = json.loads(msg_raw)
  return msg

def send_message(sock, msg):
  return sock.send(msg)

def read_all(sock)
  global received_buffer
  while True:
    msg = receive_message(sock)
    if msg is None: 
      return
    else: 
      received_buffer.append(msg)
    

  

# process functions for each role
def process_buff_foll():
  global replica_response_buffer, received_buffer, reqvot_buffer, received_votes, voted_for, current_term, cluster_size

def process_buff_lead():
  global replica_response_buffer, received_buffer, reqvot_buffer, received_votes, voted_for, current_term, cluster_size

def process_buff_cand():
  global replica_response_buffer, received_buffer, reqvot_buffer, received_votes, voted_for, current_term, cluster_size
  if len(received_buffer) == 0: return

  remainder = []
  while len(received_buffer) > 0:
    msg = received_buffer.pop(0)

    if msg['type'] == 'reqvote_res':

      if msg['term'] > current_term:
        bow_out(msg['term'], msg['leader'])
        received_buffer = remainder + received_buffer
        return process_buff_foll() # convert to follower    
      if msg['term'] == current_term and msg['voteGranted'] == True:
        received_votes.add(msg['src'])
        reqvot_buffer.pop(msg['src'])
        if len(received_votes) > (cluster_size / 2):
          inaugurate()
          received_buffer = remainder + received_buffer
          return process_buff_lead() # convert to leader and co        
  
    elif msg['type'] == 'reqvot':
    
      if msg['term'] > current_term:
        bow_out(msg['term'], msg['leader'])
        # don't deal with actually voting, let the follower function handle that
        received_buffer = remainder + [msg] + received_buffer
        return process_buff_foll() # convert to follower
      else:
        resp = {'term': current_term, 'voteGranted': False}
        resp = add_headers(resp, msg['src'], 'reqvot_res')
        replica_response_buffer.append(json.dumps(resp))

    elif msg['type'] == 'appent':

      if msg['term'] >= current_term:
        bow_out(msg['term'], msg['leader'])
        received_buffer = remainder + [msg] + received_buffer
        return process_buff_foll()
      else:
        resp = {'term': current_term, 'success': False}
        resp = add_headers(resp, msg['src'], 'appent_res')
        replica_response_buffer.append(json.dumps(resp))

    elif msg['type'] == 'appent_res':
      if msg['term'] >= current_term:
        bow_out(msg['term'], msg['leader'])
        received_buffer = remainder + received_buffer
        return process_buff_foll() 
    
    elif msg['type'] in ['get', 'put']: # add gets and puts to remainder, but this might cause a latency spike? maybe should redirect?
      remainder.append(msg)


# event loop
while True:

  # always respond to clients if you can
  for msg in client_response_buffer:
    send_message(sock, msg)

  # always respond to other replicas if you can
  for msg in replica_response_buffer:
    send_message(sock, msg)

  # send
  if my_role == CAND:
    clock = time.time()
    for rid in replica_ids:
      if (clock - rep_timeouts[rid]['last'] > rep_timeouts[rid]['to']) and reqvot_buffer.get(rid): # send reqvot
        send_message(sock, reqvot_buffer[rid])
        rep_timeouts[rid]['last'] = clock
  elif my_role == LEAD:
    clock = time.time()
    for rid in replica_ids:
      if (clock - rep_timeouts[rid]['last'] > rep_timeouts[rid]['to']):
        send_message(sock, build_appent(rid))
        rep_timeouts[rid]['last'] = clock
  elif my_role == FOLL:
    # no special things to send if you're a follower! just listen and respond!    

  # receive
  read_all(sock)

  # process
  if my_role == CAND:
    process_buff_cand()
  elif my_role == LEAD:
    process_buff_lead()
  elif my_role == FOLL:
    process_buff_foll()

  # timeout test
  if my_role != LEAD and time.time() - last_event > election_timeout:
    nominate()


  
