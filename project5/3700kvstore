#!/usr/bin/env python

import sys, socket, select, time, json, random

######################################
######## pre-loop definitions ########
######################################

# cluster size
cluster_size = len(sys.argv) - 1

# Your ID number
my_id = sys.argv[1]

# The ID numbers of all the other replicas
replica_ids = sys.argv[2:]

# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
sock.connect(my_id)

last_leader_msg = time.time()
is_leader = False
election_timeout = random.uniform(0.3, 0.6)

leader = 'FFFF'

currentTerm = 0
votedFor = {}
votesReceived = []
is_holding_election = False

log = []

commitIndex = 0
lastApplied = 0

# leader state
nextIndex = []
matchIndex = []

heartbeat_timeout = 0.1
last_heartbeat = time.time()

kvstore = {}

DEBUG = False

######################################
######## function definitions ########
######################################

def debug(msg, **kwargs):
  if DEBUG or kwargs.get('force'):
    print("Replica " + str(my_id) + " :: " + str(time.time()) + " :: " + msg)

def send_to_replicas(key, val):
  debug("Sending appent to replicas")
  global my_id, leader, currentTerm, replica_ids, sock, last_heartbeat, votedFor
  htbt = {}
  htbt['src'] = my_id
  htbt['leader'] = leader
  htbt['type'] = 'appent'
  htbt['entries'] = [{"key": key, "value": val}]
  htbt['term'] = currentTerm
  for rid in replica_ids:
    htbt['dst'] = rid
    sock.send(json.dumps(htbt))
    # naive.... also need ot check quorum achievement
 

def respond_leader_get_put(msg):
  debug("Handling a get/put as the leader")
  global leader, my_id, kvstore

  response = {}
  response['src'] = my_id
  response['dst'] = msg['src']
  response['leader'] = leader
  response['type'] = 'ok'
  response['MID'] = msg['MID']

  if msg['type'] == 'get':
    val = kvstore.get(msg['key'])
    response['value'] = "" if val is None else val
    return sock.send(json.dumps(response))
  elif msg['type'] == 'put':
    # naive not-really-consensus-implementation
    kvstore[msg['key']] = msg['value']
    log.append({'key': msg['key'], 'value': msg['value']})
    send_to_replicas(msg['key'], msg['value'])
    return sock.send(json.dumps(response))
    

def respond_get_put(msg):
  debug("Responding to a get or a put")
  global is_leader, leader, sock
  if leader == 'FFFF':
    return respond_with_fail(msg)
  if is_leader:
    return respond_leader_get_put(msg)
  debug("Responding with redirect")
  response = {}
  response['src'] = my_id
  response['dst'] = msg['src']
  response['leader'] = leader
  response['type'] = 'redirect'
  response['MID'] = msg['MID']
  return sock.send(json.dumps(response))

# respond to the provided msg with a failure message
def respond_with_fail(msg):
  debug("Responding with fail")
  response = {}
  response['src'] = my_id
  response['dst'] = msg['src']
  response['leader'] = msg['leader']
  response['type'] = 'fail'
  response['MID'] = msg['MID']
  response_raw = json.dumps(response)
  return sock.send(response_raw)

# handle append entries
def handle_append_entries(msg):
  debug("Handling append entries")
  global currentTerm, leader, last_leader_msg
  
  last_leader_msg = time.time()
  
  res = {}
  res['src'] = my_id
  res['dst'] = msg['src']
  res['type'] = 'appent_res'
  ## do something
  if msg['term'] < currentTerm:
    res['leader'] = leader
    res['term'] = currentTerm
    res['success'] = False
    return sock.send(json.dumps(res))
  else:
    for entry in msg['entries']:
      kvstore[entry['key']] = entry['value']
      log.append({'key': entry['key'], 'value': entry['value']})
    leader = msg['leader']
    currentTerm = msg['term']
    res['term'] = currentTerm
    res['success'] = True
    res['leader'] = leader
    election_timeout = random.uniform(0.3, 0.6)
    return sock.send(json.dumps(res))


# request a vote
def request_vote(rid):
  debug("Requesting vote from" + str(rid))
  req = {}
  req['src'] = my_id
  req['dst'] = rid
  req['type'] = 'reqvot'
  req['leader'] = 'FFFF'
  req['term'] = currentTerm
  req['candidateId'] = my_id
  req['lastLogIndex'] = len(log) - 1
  req['lastLogTerm'] = 0
  req_raw = json.dumps(req)
  sock.send(req_raw)

# begin election
def begin_election():
  debug("Beginning election")
  global currentTerm, votedFor, votesReceived, is_holding_election, last_leader_msg
  currentTerm = currentTerm + 1
  votedFor = my_id
  votesReceived = [my_id]
  is_holding_election = True
  last_leader_msg = time.time() 
  for rid in replica_ids:
    request_vote(rid)

# handle request vote
def handle_request_vote(msg):
  debug("Received request for vote from " + str(msg['src'])) 
  global votedFor, currentTerm, last_leader_msg
  res = {}
  res['src'] = my_id
  res['dst'] = msg['src']
  res['type'] = 'reqvot_res'
  res['leader'] = 'FFFF'
  if msg['term'] < currentTerm:
    res['voteGranted'] = False
  elif votedFor.get(currentTerm, None) in [None, msg['candidateId']]:
    #  initial election case  | every other election  TODO: check log matching
    if ((currentTerm == 0) or (msg['term'] >= currentTerm)): 
      res['voteGranted'] = True
      votedFor[currentTerm] = msg['src']
    else:
      res['voteGranted'] = False
  else:
    res['voteGranted'] = False

  res['term'] = currentTerm
  last_leader_msg = time.time()
  return sock.send(json.dumps(res))

def send_heartbeat():
  debug("Sending heartbeat")
  global my_id, leader, currentTerm, replica_ids, sock, last_heartbeat, votedFor
  htbt = {}
  htbt['src'] = my_id
  htbt['leader'] = leader
  htbt['type'] = 'appent'
  htbt['entries'] = []
  htbt['term'] = currentTerm
  for rid in replica_ids:
    htbt['dst'] = rid
    sock.send(json.dumps(htbt))
  last_heartbeat = time.time()
  return

def handle_vote_received(msg):
  debug('Received vote from ' + str(msg['src']))
  global leader, is_leader, votesReceived, is_holding_election
  if not is_holding_election or not msg['voteGranted']:
    return
  votesReceived.append(msg['src'])
  if len(votesReceived) > (cluster_size / 2):
    debug("I've won the election")
    # we won the election! 
    # send a heartbeat 
    leader = my_id
    is_leader = True
    votesReceived = []
    is_holding_election = False
    send_heartbeat() 


######################################
############## event loop ############
######################################

debug("Election Timeout " + str(election_timeout))

while True:

  if is_leader and time.time() - last_heartbeat > heartbeat_timeout:
    send_heartbeat()	
  
  ready = select.select([sock], [], [], 0.01)[0]
  
  if sock in ready:
    msg_raw = sock.recv(32768)
	
    if len(msg_raw) == 0: continue

    msg = json.loads(msg_raw)

    if msg['dst'] not in my_id: 
      debug('Message not for me')
      continue
	  
    if msg['type'] in ['get', 'put']:
      respond_get_put(msg)
    elif msg['type'] == 'appent':
      handle_append_entries(msg)
      last_leader_msg = time.time()
    elif msg['type'] == 'reqvot':
      handle_request_vote(msg)
    elif msg['type'] == 'reqvot_res':
      handle_vote_received(msg)
      
		
  clock = time.time()
  # if election timeout has occurred
  if not is_leader and (clock - last_leader_msg) > election_timeout:
    begin_election()
    last = clock


